/* 
给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。
思路，遍历，遇到mat[i][j] == 0, 向四周扩展，直到遇到下一个0，
初始化，res[i][j] == INT_MAX

广度优先遍历，使用队列，虚拟化一个超级零，
 */
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
using namespace std;

class Solution1{
private:
    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
public:
    void bfs(vector<vector<int>>& mat, pair<int, int> p, vector<vector<int>>& res){
        if(mat[p.first][p.second] == 0) return;

        for(int i = 0; i < 4; ++i){
            int new_i = p.first + dirs[i][0];
            int new_j = p.second + dirs[i][1];

            if(new_i >=0 && new_i < mat.size() && new_j >= 0 && new_j < mat[0].size() && mat[new_i][new_j] == 1){

                res[new_i][new_j] = min(res[new_i][new_j], res[p.first][p.second] + 1);

                bfs(mat, {new_i, new_j}, res);
            }
        }
        
    }
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat){
        int m = mat.size(), n = mat[0].size();
        vector<vector<int>> res(m, vector<int>(n, INT_MAX));
        
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(mat[i][j] == 0){
                    res[i][j] = 0;
                    bfs(mat, {i, j}, res);
                }
            }
        }
        return res;
    }
};

// int main(){
//     vector<vector<int>> mat = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
//     Solution s1;
//     // cout<<s1.updateMatrix(mat);
//     vector<vector<int>> res = s1.updateMatrix(mat);
// }

/* 
对于矩阵中的每一个元素，如果它的值为 0，那么离它最近的 0 就是它自己。如果它的值为 1，那么我们就需要找出离它最近的 0，并且返回这个距离值。那么我们如何对于矩阵中的每一个 1，都快速地找到离它最近的 0 呢？
我们不妨从一个简化版本的问题开始考虑起。假设这个矩阵中恰好只有一个 0，我们应该怎么做？由于矩阵中只有一个 0，那么对于每一个 1，离它最近的 0 就是那个唯一的 0。如何求出这个距离呢？我们可以想到两种做法：

    如果 00 在矩阵中的位置是 (i_0, j_0)，11 在矩阵中的位置是 (i_1, j_1)，那么我们可以直接算出 0 和 1 之间的距离。因为我们从 1 到 0 需要在水平方向走 |i_0 - i_1| 步，竖直方向走 |j_0 - j_1| 步，那么它们之间
的距离就为 |i_0 - i_1| + |j_0 - j_1|；

    我们可以从 0 的位置开始进行 广度优先搜索。广度优先搜索可以找到从起点到其余所有点的 最短距离，因此如果我们从 0 开始搜索，每次搜索到一个 1，就可以得到0 到这个 1 的最短距离，也就离这个 1 最近的 0 的距离了
（因为矩阵中只有一个 0）。
举个例子，如果我们的矩阵为：
_ _ _ _
_ 0 _ _
_ _ _ _
_ _ _ _
其中只有一个 0，剩余的 1 我们用短横线表示。如果我们从 0 开始进行广度优先搜索，那么结果依次为：
_ _ _ _         _ 1 _ _         2 1 2 _         2 1 2 3         2 1 2 3
_ 0 _ _   ==>   1 0 1 _   ==>   1 0 1 2   ==>   1 0 1 2   ==>   1 0 1 2
_ _ _ _         _ 1 _ _         2 1 2 _         2 1 2 3         2 1 2 3
_ _ _ _         _ _ _ _         _ 2 _ _         3 2 3 _         3 2 3 4
也就是说，在广度优先搜索的每一步中，如果我们从矩阵中的位置 x 搜索到了位置 y，并且 y 还没有被搜索过，那么位置 y 离 0 的距离就等于位置 x 离 0 的距离加上 1。

对于上面的两种做法，第一种看上去简洁有效，只需要对每一个位置计算就行；第二种需要实现广度优先搜索，会复杂一些。但是，别忘了我们的题目中会有不止一个 0，这样以来，如果我们要使用第一种做法，就必须对于每个 1 
计算一次它到所有的 0 的距离，再从中取一个最小值，时间复杂度会非常高，无法通过。而对于第二种做法，我们可以很有效地处理有多个 0 的情况。

    处理的方法很简单：我们在进行广度优先搜索的时候会使用到队列，在只有一个 0 的时候，我们在搜索前会把这个 0 的位置加入队列，才能开始进行搜索；如果有多个 0，我们只需要把这些 0 的位置都加入队列就行了。

我们还是举一个例子，在这个例子中，有两个 0：
_ _ _ _
_ 0 _ _
_ _ 0 _
_ _ _ _
我们会把这两个 0 的位置都加入初始队列中，随后我们进行广度优先搜索，找到所有距离为 1 的 1：
_ 1 _ _
1 0 1 _
_ 1 0 1
_ _ 1 _
接着重复步骤，直到搜索完成：
_ 1 _ _         2 1 2 _         2 1 2 3
1 0 1 _   ==>   1 0 1 2   ==>   1 0 1 2
_ 1 0 1         2 1 0 1         2 1 0 1
_ _ 1 _         _ 2 1 2         3 2 1 2
这样做为什么是正确的呢？
    我们需要对于每一个 1 找到离它最近的0。如果只有一个 0 的话，我们从这个 0 开始广度优先搜索就可以完成任务了；
    但在实际的题目中，我们会有不止一个 0。我们会想，要是我们可以把这些 0 看成一个整体好了。有了这样的想法，我们可以添加一个「超级零」，它与矩阵中所有的 0 相连，这样的话，任意一个 1 到它最近的 0 的距离，会
等于这个 1 到「超级零」的距离减去一。由于我们只有一个「超级零」，我们就以它为起点进行广度优先搜索。这个「超级零」只和矩阵中的 0 相连，所以在广度优先搜索的第一步中，「超级零」会被弹出队列，而所有的 0 会
被加入队列，它们到「超级零」的距离为 1。这就等价于：一开始我们就将所有的 0 加入队列，它们的初始距离为 0。这样以来，在广度优先搜索的过程中，我们每遇到一个 1，就得到了它到「超级零」的距离减去一，也就是 这个 1 
到最近的 0 的距离。

熟悉「最短路」的读者应该知道，我们所说的「超级零」实际上就是一个「超级源点」。在最短路问题中，如果我们要求多个源点出发的最短路时，一般我们都会建立一个「超级源点」连向所有的源点，
用「超级源点」到终点的最短路等价多个源点到终点的最短路。
 */

class Solution{
private:
    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix){
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> res(m, vector<int>(n, -1));//存储结果，其中初始化为-1是为了判断该点是否已经搜索过，如果搜索过则res[i][j] != -1
        queue<pair<int, int>> qu;

        for(int i = 0; i < m; ++i){//利用虚拟的源零点，将矩阵中所有的0入队
            for(int j = 0; j < n; ++j){
                if(matrix[i][j] == 0){
                    qu.push({i, j});
                    res[i][j] = 0;
                }
            }
        }

        while(!qu.empty()){//广度优先搜索
            pair<int, int> temp = qu.front();
            qu.pop();

            for(int d = 0; d < 4; ++d){//遍历dir的四个方向，temp = (i,j) 加dir的四个元素刚刚好是(i,j)的上下左右四个位置
                int new_i = temp.first + dir[d][0];//获得(i,j)的四周坐标
                int new_j = temp.second + dir[d][1];

                if(new_i >=0 && new_i < m && new_j >= 0 && new_j < n){//新的坐标在矩阵内部符合要求
                    if(res[new_i][new_j] == -1){//判断[new_i][new_j]是否遍历过，如果没有遍历过则将其res置为res[i][j] + 1; 不需要考虑是否matrix[new_i][new_j] == 1，
                    //因为0已经全部入队了，没有入队的都是1，只存在是否访问过的区别
                        res[new_i][new_j] = res[temp.first][temp.second] + 1;
                        qu.push({new_i, new_j});//将刚遍历过的元素入队  qu.emplace(new_i, new_j) emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数
                    }
                }
            }
        }

        return res;
    }
};