
# dp 五步法
1. 确定dp数组以及下标的含义
2. 确定递推公式 \*
3. dp数组初始化
4. 确定遍历顺序
5. 举例推导dp数组

## **总结**
### 递推公式
* 能否装满背包（或者最多背包可以装多少）：dp[j] = max(dp[j], dp[j - weight[i]] + vlaue[i])
    * 416 分割等和子集
    * 1049 最后一块石头的重量
* 问装满背包有几种方法 ： dp[j] += dp[j - weight[i]]
    * 494 目标和
    * 518 零钱兑换2
    * 377 组合总和4
    * 70 爬楼梯进阶版（完全背包
* 问装满背包的最大价值 ： dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    * 474 一和零
* 问装满背包所有物品的最小个数： dp[j] = min(dp[j], dp[j - coins[i]] + 1)
    * 322 零钱兑换
    * 279 完全平方数

### 遍历顺序
* 01背包
  * 01背包 使用**二维数组**先遍历物品与先遍历背包容量都是可以的，第二层for循环是从小到大遍历
  * 使用**一维滚动数组时**只能先遍历物品再遍历背包，第二层的for循环是从大到小遍历
* 完全背包
  * 完全背包的**一维数组**遍历顺序都可以，第二层的for循环是从小到大遍历。
  * **如果求组合数就是外层for循环遍历物品，内层for遍历背包**
  * **如果求排列数就是外层for遍历背包，内层for循环遍历物品**

# 基础题目
* 509 斐波那契数列
* 70 爬楼梯
* 746 使用最小花费爬楼梯
* 62 不同路径 **dp[i][j]到达i*j的右下角一共有多少中路径**
* 63 不同路径2
* 343 整数拆分
* 96 不同的二叉搜索树

# 背包问题
## 01背包
* 0416 分割等和子集
* 1049 最后一块石头的重量2
* 494 目标和 *装满背包有几种方法，一般公式都是：dp[j] += dp[j - nums[i]]*
* 474 一和零

一维数组 dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```c++
for(int i = 0; i < n; ++i){//遍历物品
    for(int j = bag_size; j >= w[i]; --j){//遍历背包容量
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

## 完全背包
* 518 零钱兑换3 *先遍历物品再遍历背包容量求出来的是组合数* **组合数**
* 377 组合总和4 *先遍历背包容量再遍历物品求出来的是排列数* **排列数**
* 70 爬楼梯（完全背包解法 **排列数** 
* 322 零钱兑换**最小数**
* 279 完全平方数 *和为j的组合共有dp[j]个递推公式一般为dp[j]=min(dp[j],dp[j-coin[i]]+1)* **最小数**
* 139 单词拆分

```c++
for(int i = 0; i <= n; ++i){//遍历物品
    for(int j = w[i]; j <= bag_size; ++j){//遍历背包容量
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

## 多重背包
* 0000 多重背包可以化为01背包来计算，代码见multiple backpack
# 打家劫舍
* 198 打家劫舍
* 213 打家劫舍2
* 337 打家劫舍3

# 股票问题
* 121 买卖股票的最佳时机（只能买卖一次
* 122 买卖股票的最佳时机（可以买卖多次
* 123 买卖股票的最佳时机（最多买卖两次
* 124 买卖股票的最佳时机（最多买卖k次
* 188 买卖股票的最佳时机含冷冻期（买卖多次，卖出有一天冷冻期
* 714 买卖股票的最佳时机含手续费（买卖多次，每次有手续费

# 子序列问题
## 子序列（不连续
* 300 最长上升子序列
* 1143 最长公共子序列
* 1035 不相交的线

## 子序列（连续
* 674 最长连续递增序列
* 718 最长重复子数组
* 53 最大子序和

## 编辑距离
* 392 判断子序列
* 115 不同的子序列
* 583 两个字符串的删除操作
* 72 编辑距离

## 回文
* 647 回文子串
* 516 最长回文子序列